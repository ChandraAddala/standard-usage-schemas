<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet
    xmlns="http://wadl.dev.java.net/2009/02"
    xmlns:wadl="http://wadl.dev.java.net/2009/02"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:c="http://www.w3.org/ns/xproc-step"
    xmlns:sch="http://docs.rackspace.com/core/usage/schema"
    xmlns:rax="http://docs.rackspace.com/api"
    xmlns:event="http://docs.rackspace.com/core/event"
    xmlns:error="http://docs.rackspace.com/core/error"
    xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:domain="http://docs.rackspace.com/event/domain"
    xmlns:novaHost="http://docs.rackspace.com/event/nova/host"
    xmlns:identityUser="http://docs.rackspace.com/event/identity/user"
    xmlns:maas="http://docs.rackspace.com/usage/maas"
    xmlns:sitesSubscription="http://docs.rackspace.com/usage/sites/subscription"
    xmlns:xslout="http://www.rackspace.com/repose/wadl/checker/Transform"
    exclude-result-prefixes="sch c"
    version="2.0">

    <xsl:namespace-alias stylesheet-prefix="xslout" result-prefix="xsl"/>
    <xsl:output method="xml" encoding="UTF-8" indent="yes"/>
    <xsl:variable name="NS_PREFIX" select="'w_ns'"/>
    <!-- Event types, excepts for USAGE, which is a special case -->
    <xsl:variable name="EVENT_TYPES" as="xs:string*"
        select="('CREATE','USAGE_SNAPSHOT','UPDATE', 'DELETE', 'SUSPEND', 'UNSUSPEND', 'EXTENDED','UP','DOWN','INFO')"/>
    
    <xsl:template match="c:directory">
        <xsl:variable name="productSchemas" as="node()" select="sch:addSchemaPos(sch:getSchemas(.))"/>
        <xsl:variable name="sampleMessages" as="node()" select="sch:getMessages(.)"/>
        <xsl:comment>
            <xsl:text>&#x0a;    THIS WADL IS AUTOGENERATED DO NOT EDIT</xsl:text>
            <xsl:text>&#x0a;    GENERATED ON: </xsl:text><xsl:value-of select="current-dateTime()"/>
            <xsl:text>&#x0a;    PRODUCT SCHEMAS:</xsl:text>
            <xsl:for-each select="//c:directory[@name = 'sample_product_schemas' and not(ancestor::c:directory/@name = 'target')]/c:file[ends-with(lower-case(@name), '.xml')]/@name">
                <xsl:sort select="."/>
                <xsl:text>&#x0a;           </xsl:text><xsl:value-of select="."/>
            </xsl:for-each>
            <xsl:text>&#x0a;</xsl:text>
        </xsl:comment>
        <xsl:text>&#x0a;</xsl:text>
        <application>
            <xsl:for-each-group select="$productSchemas/sch:productSchema" group-by="@namespace">
                <xsl:namespace name="{sch:ns(current-group()[1]/@pos)}" select="current-group()[1]/@namespace"/>
            </xsl:for-each-group>
            <xsl:for-each-group select="$productSchemas//sch:productSchema" group-by="@serviceCode">
                <xsl:variable name="id" select="current-group()[1]/@serviceCode"/>
                <resource_type id="{$id}">
                    <method id="add{$id}Entry" name="POST">
                    <xsl:comment>GENERATED FILE! Do Not Hand Edit!</xsl:comment>                  
                        <wadl:doc title="Add {sch:lookupServiceCode(current-grouping-key())} Event" xmlns="http://docbook.org/ns/docbook">
                            <xsl:comment>GENERATED FILE! Do Not Hand Edit!</xsl:comment>
                            <para role="shortdesc">Add <xsl:value-of select="sch:lookupServiceCode(current-grouping-key())"/> event.</para>
                            <!-- TODO: write out product schema tables here -->
                            <xsl:apply-templates select="current-group()" mode="wadlDoc">
                                <xsl:with-param name="sampleMessages" select="$sampleMessages"/>
                                <xsl:with-param name="context">addEntry</xsl:with-param>
                            </xsl:apply-templates>                            
                        </wadl:doc>
                        <request>
                            <representation mediaType="application/atom+xml" element="atom:entry">
                                <xsl:call-template name="sch:param">
                                    <xsl:with-param name="type" select="'USAGE'"/>
                                    <xsl:with-param name="schemas" select="current-group()[not(@type) or ('USAGE' = tokenize(@type,' '))]"/>
                                </xsl:call-template>
                                <xsl:for-each select="$EVENT_TYPES">
                                    <xsl:variable name="type" select="."/>
                                    <xsl:call-template name="sch:param">
                                        <xsl:with-param name="type" select="."/>
                                        <xsl:with-param name="schemas" select="current-group()[$type = tokenize(@type,' ')]"/>
                                    </xsl:call-template>
                                </xsl:for-each>
                                <xsl:call-template name="sch:cross-check-params">
                                    <xsl:with-param name="schemas" select="current-group()"/>
                                </xsl:call-template>
                                <xsl:call-template name="sch:forbid-event-error" />

                                <xsl:call-template name="sch:searchable">
                                    <xsl:with-param name="schemas" select="current-group()"/>
                                    <xsl:with-param name="nscount" select="count(sch:getNSVersions($productSchemas//sch:productSchema))"/>
                                </xsl:call-template>
                                
                                <xsl:for-each select="./sch:attribute[@use='synthesized']">
                                    <xsl:variable name="ns" as="xs:string" select="sch:ns(../@pos)"/>
                                    <xsl:variable name="attributeName" select="@name"/>
                                    <param name="checkSynthesized_{$attributeName}"
                                           style="plain"
                                           required="true"
                                           path="not(/atom:entry/atom:content/event:event/{$ns}:product/@{$attributeName})"
                                           rax:message="The synthesized attribute '{$attributeName}' should not be included in the original event."/>
                                </xsl:for-each>

                                <!--
                                    Hack, add nova updown check.
                                -->
                                <xsl:if test="$id = 'CloudServersOpenStack'">
                                    <param name="checkUp"
                                           style="plain"
                                           required="true"
                                           path="if (/atom:entry/atom:content/event:event/@type = 'UP') then not(/atom:entry/atom:content/event:event/novaHost:product/@checkStatus = 'CRITICAL') else true()"
                                           rax:message="If message is UP type then checkStatus cannot be CRITICAL."/>
                                    <param name="checkDown"
                                           style="plain"
                                           required="true"
                                           path="if (/atom:entry/atom:content/event:event/@type = 'DOWN') then not(/atom:entry/atom:content/event:event/novaHost:product/@checkStatus = 'OK') else true()"
                                           rax:message="If message is DOWN type then checkStatus cannot be OK."/>
                                </xsl:if>

                                <!--
                                    Workaround, add a param for CloudIdentity
                                -->
                                <xsl:if test="$id = 'CloudIdentity'">
                                    <param name="checkUpdate"
                                           style="plain"
                                           required="true"
                                           path="if (/atom:entry/atom:content/event:event/@type = 'UPDATE' and /atom:entry/atom:content/event:event/identityUser:product/@version = '2') then /atom:entry/atom:content/event:event/identityUser:product/@updatedAttributes else true()"
                                           rax:message="For version 2 and type is UPDATE, the updatedAttributes attribute is required."/>
                                    <param name="checkNonUpdate"
                                           style="plain"
                                           required="true"
                                           path="if (/atom:entry/atom:content/event:event/@type != 'UPDATE' and /atom:entry/atom:content/event:event/identityUser:product/@version = '2') then not(/atom:entry/atom:content/event:event/identityUser:product/@updatedAttributes) else true()"
                                           rax:message="For version 2 and type is other than UPDATE, the updatedAttributes attribute should not be used."/>
                                </xsl:if>

                                <!--
                                    B-51154: restrict the use of GLOBAL DC/Region
                                    This can be implemented inside the product schema XMLs once B-50883, 
                                    which depends on Repose 2.8.6 or above, is implemented.
                                -->
                                <xsl:choose>
                                    <xsl:when test="$id = 'CloudMonitoring'">
                                        <param name="checkDatacenter"
                                               style="plain"
                                               required="true"
                                               path="if ( not(/atom:entry/atom:content/event:event/maas:product/@resourceType = 'CHECK') and (not(/atom:entry/atom:content/event:event/@dataCenter) or /atom:entry/atom:content/event:event/@dataCenter = 'GLOBAL') ) then false() else true()"
                                               rax:message="For this type of Monitoring event, @dataCenter must be present and can not be GLOBAL."/>
                                        <param name="checkRegion"
                                               style="plain"
                                               required="true"
                                               path="if ( not(/atom:entry/atom:content/event:event/maas:product/@resourceType = 'CHECK') and (not(/atom:entry/atom:content/event:event/@region) or /atom:entry/atom:content/event:event/@region = 'GLOBAL') ) then false() else true()"
                                               rax:message="For this type of Monitoring event, @region must be present and can not be GLOBAL."/>
                                        <rax:preprocess href="atom_hopper_pre.xsl"/>
                                    </xsl:when>
                                    <xsl:when test="$id = 'CloudSites'">
                                        <param name="checkDatacenter"
                                               style="plain"
                                               required="true"
                                               path="if ( not(/atom:entry/atom:content/event:event/sitesSubscription:product/@resourceType = 'SITES_SUBSCRIPTION') and (not(/atom:entry/atom:content/event:event/@dataCenter) or /atom:entry/atom:content/event:event/@dataCenter = 'GLOBAL') ) then false() else true()"
                                               rax:message="For this type of Sites event, @dataCenter must be present and can not be GLOBAL."/>
                                        <param name="checkRegion"
                                               style="plain"
                                               required="true"
                                               path="if ( not(/atom:entry/atom:content/event:event/sitesSubscription:product/@resourceType = 'SITES_SUBSCRIPTION') and (not(/atom:entry/atom:content/event:event/@region) or /atom:entry/atom:content/event:event/@region = 'GLOBAL') ) then false() else true()"
                                               rax:message="For this type of Sites event, @region must be present and can not be GLOBAL."/>
                                        <rax:preprocess href="atom_hopper_pre.xsl"/>
                                    </xsl:when>
                                    <xsl:when test="$id = 'DomainRegistration'">
                                        <param name="checkDatacenter"
                                               style="plain"
                                               required="true"
                                               path="if ( not(/atom:entry/atom:content/event:event/domain:product/@resourceType = 'DOMAIN_SUBSCRIPTION') and (not(/atom:entry/atom:content/event:event/@dataCenter) or /atom:entry/atom:content/event:event/@dataCenter = 'GLOBAL') ) then false() else true()"
                                               rax:message="For this type of Domain event, @dataCenter must be present and can not be GLOBAL."/>
                                        <param name="checkRegion"
                                               style="plain"
                                               required="true"
                                               path="if ( not(/atom:entry/atom:content/event:event/domain:product/@resourceType = 'DOMAIN_SUBSCRIPTION') and (not(/atom:entry/atom:content/event:event/@region) or /atom:entry/atom:content/event:event/@region = 'GLOBAL') ) then false() else true()"
                                               rax:message="For this type Domain of event, @region must be present and can not be GLOBAL."/>
                                        <rax:preprocess href="atom_hopper_pre.xsl"/>
                                    </xsl:when>
                                    <xsl:otherwise>
                                        <param name="checkDatacenter"
                                               style="plain"
                                               required="true"
                                               path="if ( (count(/atom:entry/atom:content/event:event) > 0 and not(/atom:entry/atom:content/event:event/@dataCenter)) or /atom:entry/atom:content/event:event/@dataCenter = 'GLOBAL') then false() else true()"
                                               rax:message="For this product usage event, @dataCenter must be present and can not be GLOBAL."/>
                                        <param name="checkRegion"
                                               style="plain"
                                               required="true"
                                               path="if ( (count(/atom:entry/atom:content/event:event) > 0 and not(/atom:entry/atom:content/event:event/@region)) or /atom:entry/atom:content/event:event/@region = 'GLOBAL') then false() else true()"
                                               rax:message="For this product usage event, @region must be present and can not be GLOBAL."/>
                                        <rax:preprocess href="atom_hopper_pre.xsl"/>
                                    </xsl:otherwise>
                                </xsl:choose>

                                <!-- per WADL schema, all rax:preprocess/extensions have to be at the bottom of params -->

                                <!-- B-57395: implementation of BigData synthesized attribute -->
                                <xsl:if test="$id = 'BigData'">
                                    <rax:preprocess href="bigdata.xsl"/>
                                </xsl:if>
                            </representation>
                        </request>
                        <!-- Okay -->
                        <response status="201">
                            <representation mediaType="application/atom+xml"/>
                        </response>
                        <!-- On Error -->
                        <response status="400 401 409 500 503">
                            <representation mediaType="application/xml"/>
                        </response>
                    </method>
                    <xsl:variable name="opencurly">{</xsl:variable>
                    <xsl:variable name="closecurly">}</xsl:variable>
                    <resource path="entries/{$opencurly}id{$closecurly}" id="getEntry_{$id}">
                        <param name="id" type="xs:anyURI" style="template"> <!-- Have to add wadl: prefix to doc to make test pass. Canonicalization seems to be messing up --><wadl:doc>urn:uuid:676f3860-447c-40a3-8f61-9791819cc82f</wadl:doc></param>
                        <method id="getEntry{$id}" name="GET">
                            <wadl:doc xml:lang="EN" title="Get {sch:lookupServiceCode(current-grouping-key())} Event" xmlns="http://docbook.org/ns/docbook">
                                <para role="shortdesc">This http request fetches one particular event whose ID is listed in the URI.</para>
                                <xsl:apply-templates select="current-group()" mode="wadlDoc">
                                    <xsl:with-param name="sampleMessages" select="$sampleMessages"/>
                                    <xsl:with-param name="context">getEntry</xsl:with-param>
                                </xsl:apply-templates>  
                            </wadl:doc>
                            <response status="200">
                                <representation mediaType="application/atom+xml"/>
                            </response>
                            <!-- On Error -->
                            <response status="400 401 409 500 503">
                                <representation mediaType="application/xml"/>
                            </response>
                        </method>                     
                    </resource>                
                </resource_type>
            </xsl:for-each-group>
        </application>
    </xsl:template>
    <xsl:template name="sch:cross-check-params">
        <xsl:param name="schemas" as="node()*"/>
        <xsl:variable name="usedTypes" select="if ($schemas[not(@type)]) then
                                               distinct-values((sch:getTypes($schemas),'USAGE'))
                                               else sch:getTypes($schemas)"
                      as="xs:string*"/>
        <xsl:variable name="allTypes"  select="('USAGE', $EVENT_TYPES)" as="xs:string*"/>
        <xsl:variable name="notUsed" select="for $t in $allTypes return if ($t = $usedTypes) then () else sch:quoted($t)" as="xs:string*"/>
        <param name="cross_check" style="plain" required="true" rax:message="Events of this type not allowed in the feed.">
            <xsl:attribute name="path">
                <xsl:text>not(/atom:entry/atom:content/event:event/@type = (</xsl:text>
                <xsl:value-of select="$notUsed" separator=","/>
                <xsl:text>))</xsl:text>
            </xsl:attribute>
        </param>
    </xsl:template>
    <xsl:template name="sch:forbid-event-error">
        <param name="forbid-event-error" 
               style="plain" 
               required="true"
               path="not(/atom:entry/atom:content/error:eventError)"
               rax:message="eventErrors are not allowed in this feed."/>        
    </xsl:template>
    <xsl:template name="sch:param">
        <xsl:param name="schemas" as="node()*"/>
        <xsl:param name="type" as="xs:string"/>
        <xsl:variable name="isUsageEvent">/atom:entry/atom:content/event:event[@type='<xsl:value-of select="$type"/>']</xsl:variable>
        <xsl:if test="$schemas">
            <xsl:variable name="nsVersions" select="sch:getNSVersions($schemas)"/>
            <xsl:variable name="events" as="xs:string*">
                <xsl:for-each select="$nsVersions">
                    <xsl:variable name="vers">
                        <xsl:variable name="v" select="tokenize(@versions,',')"/>
                        <xsl:choose>
                            <xsl:when test="count($v) = 1">
                                <xsl:value-of select="$v[1]"/>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:value-of select="concat('(',@versions,')')"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:variable>
                    <xsl:value-of select="concat($isUsageEvent,'/',@pfix,':product[@version = ',$vers,']')"/>
                </xsl:for-each>
            </xsl:variable>
            <param name="{lower-case($type)}" style="plain" required="true">
                <xsl:attribute name="path">
                    <xsl:text>if (</xsl:text><xsl:value-of select="$isUsageEvent"/>
                    <xsl:text>) then (</xsl:text>
                    <xsl:value-of select='$events' separator=","/>
                    <xsl:text>) else true()</xsl:text>
                </xsl:attribute>
                <xsl:attribute name="rax:message">
                    <xsl:text>Only </xsl:text><xsl:value-of select="lower-case($type)"/>
                    <xsl:text> messages with product attributes in the following namespaces are allowed on this feed: </xsl:text>
                    <xsl:value-of select="for $n in $nsVersions return concat($n/@namespace,' version(s) (',$n/@versions,')')" separator=", "/>
                </xsl:attribute>
            </param>
        </xsl:if>
    </xsl:template>
    <xsl:function name="sch:getNSVersions" as="node()*">
        <xsl:param name="schemas" as="node()*"/>
        <xsl:for-each-group select="$schemas" group-by="@namespace">
            <xsl:variable name="ns" as="xs:string" select="sch:ns(current-group()[1]/@pos)"/>
            <xsl:variable name="versions" as="xs:string*" select="current-group()/@version"/>
            <sch:ns pfix="{$ns}" namespace="{current-group()[1]/@namespace}">
                <xsl:attribute name="versions">
                    <xsl:value-of select="for $v in $versions return sch:quoted($v)" separator=","/>
                </xsl:attribute>
            </sch:ns>
        </xsl:for-each-group>
    </xsl:function>
    <xsl:template name="sch:searchable">
        <xsl:param name="schemas" as="node()*"/>
        <xsl:param name="nscount" as="xs:integer"/>
        <xsl:variable name="excludePrefixes" as="xs:string*"
                      select="('event', 'rax', 'util', 'xs',
                               for $i in 1 to $nscount return concat($NS_PREFIX,xs:string($i)))"/>
        <!--
            If we have at least one searchable attribute, then
            we need to add a preproc to handle it.
        -->
        <xsl:if test="$schemas//sch:attribute/@searchable">
            <rax:preprocess>
                <xslout:stylesheet
                    xmlns:event="http://docs.rackspace.com/core/event"
                    xmlns:atom="http://www.w3.org/2005/Atom"
                    version="1.0">
                    <xsl:attribute name="exclude-result-prefixes">
                        <xsl:value-of select="$excludePrefixes" separator=" "/>
                    </xsl:attribute>
                        <xslout:import href="util.xsl"/>
                        <xslout:output method="xml" encoding="UTF-8"/>
                        <xslout:template match="text()" mode="category"/>
                        <xslout:template match="node() | @*" mode="category">
                            <xslout:apply-templates select="@* | node()" mode="category"/>
                        </xslout:template>
                        <xsl:apply-templates select="$schemas" mode="addCategory"/>
                </xslout:stylesheet>
            </rax:preprocess>
        </xsl:if>
    </xsl:template>
    <xsl:template match="sch:productSchema[sch:attribute/@searchable | sch:attributeGroup/sch:attribute/@searchable]"
                  mode="addCategory">
        <xsl:variable name="namespace" as="xs:anyURI" select="@namespace"/>
        <xsl:variable name="version" as="xs:string" select="@version"/>
        <xslout:template match="atom:entry[atom:content/event:event/pf:product/@version='{$version}']">
            <xsl:namespace name="pf" select="$namespace"/>
            <atom:entry>
                <xslout:apply-templates select="@*"/>
                <atom:id><xslout:value-of select="atom:id"/></atom:id>
                <xslout:apply-templates mode="category" select="@* | node()"/>
                <xslout:apply-templates select="node()"/>
            </atom:entry>
        </xslout:template>
        <xslout:template match="atom:entry[atom:content/event:event/pf:product/@version='{$version}']/atom:id">
            <xsl:namespace name="pf" select="$namespace"/>
        </xslout:template>
        <xsl:if test="sch:attribute/@searchable">
            <xslout:template match="pf:product[@version='{$version}']" mode="category">
                <xsl:namespace name="pf" select="$namespace"/>
                <xsl:apply-templates mode="addCategory" select="sch:attribute"/>
                <xslout:apply-templates mode="category" select="@* | node()"/>
            </xslout:template>
        </xsl:if>
        <xsl:for-each select="sch:attributeGroup[sch:attribute/@searchable]">
            <xslout:template match="pf:{@name}[../@version='{$version}']" mode="category">
                <xsl:namespace name="pf" select="$namespace"/>
                <xsl:apply-templates mode="addCategory" select="sch:attribute"/>
                <xslout:apply-templates mode="category" select="@* | node()"/>
            </xslout:template>
        </xsl:for-each>
    </xsl:template>
    <xsl:template match="sch:attribute[@searchable]" mode="addCategory">
        <xsl:variable name="inAttribute" as="xs:boolean"
                      select="name(..) = 'attributeGroup'"/>
        <xslout:call-template name="addCategory">
            <xslout:with-param name="term" select="@{@name}"/>
            <xslout:with-param name="prefix"
                               select="'{if ($inAttribute) then concat(../@name,'.',@name) else @name}:'"/>
            <xsl:if test="@default">
                <xslout:with-param name="default" select="'{@default}'"/>
            </xsl:if>
        </xslout:call-template>
    </xsl:template>
    <xsl:function name="sch:ns" as="xs:string">
        <xsl:param name="pos" as="xs:integer"/>
        <xsl:value-of select="concat($NS_PREFIX,$pos)"/>
    </xsl:function>
    <xsl:function name="sch:quoted" as="xs:string">
        <xsl:param name="in" as="xs:string"/>
        <xsl:variable name="q" select="''''"/>
        <xsl:value-of select="concat($q,$in,$q)"/>
    </xsl:function>
    <xsl:function name="sch:getTypes" as="xs:string*">
        <xsl:param name="schemas" as="node()*"/>
        <xsl:copy-of select="distinct-values(for $s in $schemas return tokenize($s/@type,' '))"/>
    </xsl:function>
    <xsl:function name="sch:getSchemas" as="node()">
        <xsl:param name="dir" as="node()"/>
        <sch:productSchemas>
            <xsl:for-each select="$dir//c:directory[@name = 'sample_product_schemas' and not(ancestor::c:directory/@name = 'target')]/c:file[ends-with(lower-case(@name), '.xml')]">
                <xsl:sort select="@name"/>
                <xsl:apply-templates select="document(resolve-uri(@name,base-uri(.)))//sch:productSchema" mode="copy"/>
            </xsl:for-each>
        </sch:productSchemas>
    </xsl:function>
    <xsl:function name="sch:getMessages" as="node()">
        <xsl:param name="dir" as="node()"/>
        <sch:messages>
            <xsl:for-each select="$dir//c:directory[@name = 'message_samples' and not(ancestor::c:directory/@name = 'target')]//c:file[ends-with(lower-case(@name), '.xml')]">
                <xsl:sort select="@name"/>
                <sch:message 
                    path="{resolve-uri(@name,base-uri(.))}" 
                    namespace="{namespace-uri(document(resolve-uri(@name,base-uri(.)))//*[local-name(.) = 'product'])}"
                    version="{document(resolve-uri(@name,base-uri(.)))//*[local-name(.) = 'product']/@version}"
                    serviceCode="{document(resolve-uri(@name,base-uri(.)))//*[local-name(.) = 'product']/@serviceCode}"
                    type="{if(document(resolve-uri(@name,base-uri(.)))/atom:entry/atom:id) then 'getEntry' else 
                           if(document(resolve-uri(@name,base-uri(.)))/atom:entry) then 'addEntry' else 'event'}"/>
            </xsl:for-each>
        </sch:messages>
    </xsl:function>
    <xsl:function name="sch:addSchemaPos" as="node()">
        <xsl:param name="schemas" as="node()"/>
        <sch:productSchemas>
            <xsl:for-each-group select="$schemas//sch:productSchema" group-by="@namespace">
                <xsl:variable name="pos" select="position()"/>
                <xsl:for-each select="current-group()">
                    <sch:productSchema pos="{$pos}">
                        <xsl:apply-templates select="@* | node()" mode="copy"/>
                    </sch:productSchema>
                </xsl:for-each>
            </xsl:for-each-group>
        </sch:productSchemas>
    </xsl:function>
    <xsl:function name="sch:lookupServiceCode">
        <xsl:param name="ServiceCode" as="xs:string"/>
        <xsl:value-of select="
            if($ServiceCode = 'CloudBlockStorage')          then 'Cloud Block Storage' 
            else if($ServiceCode = 'CloudDNS')              then 'Cloud DNS'
            else if($ServiceCode = 'CloudFiles')            then 'Cloud Files'
            else if($ServiceCode = 'CloudSites')            then 'Cloud Sites'
            else if($ServiceCode = 'DomainRegistration')    then 'Domain Registration'
            else if($ServiceCode = 'CloudDatabase')         then 'Cloud Database'
            else if($ServiceCode = 'Glance')                then 'Glance'
            else if($ServiceCode = 'CloudLoadBalancers')    then 'Cloud Loadbalancers'
            else if($ServiceCode = 'CloudServers')          then 'Cloud Servers'
            else if($ServiceCode = 'RHEL')                  then 'RedHat Enterprise Linux'
            else if($ServiceCode = 'CloudMonitoring')       then 'Cloud Monitoring'
            else if($ServiceCode = 'CloudServersOpenStack') then 'Cloud Servers (OpenStack)'
            else if($ServiceCode = 'BigData')               then 'Big Data'
            else if($ServiceCode = 'CloudBackup')           then 'Cloud Backup'
            else if($ServiceCode = 'CloudQueues')           then 'Cloud Queueus'
            else if($ServiceCode = 'AtomHopper')            then 'Atom Hopper'
            else $ServiceCode"/>
    </xsl:function>
    <xsl:template match="node() | @*" mode="copy" priority="2">
        <xsl:copy>
            <xsl:apply-templates select="@* | node()" mode="copy"/>
        </xsl:copy>
    </xsl:template>
    <xsl:template match="text()" mode="#all"/>
    
    <xsl:template match="sch:productSchema" mode="wadlDoc" xmlns="http://docbook.org/ns/docbook">
        <xsl:param name="sampleMessages"/>
        <xsl:param name="context"/>
        <xsl:variable
            name="content"
            select="unparsed-text(resolve-uri(
                ($sampleMessages//sch:message[
                    @type = $context and
                    @namespace = current()/@namespace and
                    @version = current()/@version and 
                    @serviceCode = current()/@serviceCode]/@path)[1], base-uri()))"/>        
        <example>
            <title><xsl:value-of select="replace(normalize-space(./sch:description),'^(.+)\.$','$1')"/>, version <xsl:value-of select="@version"/></title>
            <xsl:if test="sch:attribute|sch:attributeGroup">
                <informaltable frame="all">                    
                    <xsl:processing-instruction name="dbhtml">table-width="100%"</xsl:processing-instruction>
                    <tgroup cols="4">
                        <colspec colname="c1" colnum="1" colwidth="3*"/>
                        <colspec colname="c2" colnum="2" colwidth="5.39*"/>
                        <colspec colname="c3" colnum="3" colwidth="2*"/>
                        <colspec colname="c4" colnum="4" colwidth="1.5*"/>
                        <thead>                
                            <row>
                                <entry>Attribute Name</entry>
                                <entry>Description</entry>
                                <entry>Type</entry>
                                <entry>Optionality</entry>
                            </row>                
                        </thead>
                        <tbody>
                            <xsl:apply-templates select="sch:attribute" mode="wadlDoc"/>
                            <xsl:apply-templates select="sch:attributeGroup" mode="wadlDoc"/>
                        </tbody>
                    </tgroup>               
                </informaltable>
            </xsl:if>
            <programlisting language="xml"><xsl:copy-of select="replace($content,'\n.*atom.*feed.*ignore.*used for testing.*(\n)','$1')"/></programlisting>
        </example>
    </xsl:template>   
    
    <xsl:template match="sch:attribute" mode="wadlDoc"  xmlns="http://docbook.org/ns/docbook">
        <row>
            <entry>
                <para><code><xsl:value-of select="@name"/></code></para>
            </entry>
            <entry>
                <para><xsl:value-of select="."/></para>
                <xsl:if test="@allowedValues"><formalpara><title>Allowed Values:</title>
                    <para><xsl:for-each select="tokenize(normalize-space(@allowedValues),' ')"><code><xsl:value-of select="."/></code><xsl:if test="not(position() = last())">, </xsl:if></xsl:for-each></para></formalpara></xsl:if>
            </entry>
            <entry>
                <para><xsl:value-of select="@type"/></para>
            </entry>
            <entry>
                <para><xsl:value-of select="if(@use = 'optional') then 'Optional' else 'Required'"/></para>
            </entry>
        </row>
    </xsl:template>
    
    <xsl:template match="sch:attributeGroup" mode="wadlDoc"  xmlns="http://docbook.org/ns/docbook">
        <xsl:variable name="frequency">
            <xsl:choose>
                <xsl:when test="@minOccurs =  @maxOccurs">must occur exactly <xsl:value-of select="@minOccurs"/> times</xsl:when>
                <xsl:when test="@minOccurs = '0' and @maxOccurs = 'unbounded'">may occur zero or more times</xsl:when>
                <xsl:when test="@minOccurs = '0' and @maxOccurs != 'unbounded'">may occur zero to <xsl:value-of select="@maxOccurs"/> times</xsl:when>
                <xsl:when test="@minOccurs != '0' and @maxOccurs = 'unbounded'">may occur <xsl:value-of select="@minOccurs"/> or more times</xsl:when>
                <xsl:when test="@minOccurs != '0' and @maxOccurs != 'unbounded'">may occur <xsl:value-of select="@minOccurs"/> to <xsl:value-of select="@maxOccurs"/> times</xsl:when>
            </xsl:choose>
        </xsl:variable>
        <row>
            <entry namest="c1" nameend="c4">
                <para><emphasis role="bold">Attribute group </emphasis><code><xsl:value-of select="@name"/></code>: <xsl:value-of select="sch:description"/></para>
                <para>The <code><xsl:value-of select="@name"/></code> element <xsl:value-of select="$frequency"/> and 
                    takes the following attributes:</para>
            </entry>
        </row>
        <xsl:apply-templates select="sch:attribute" mode="wadlDoc"/>
    </xsl:template>
    
</xsl:stylesheet>
