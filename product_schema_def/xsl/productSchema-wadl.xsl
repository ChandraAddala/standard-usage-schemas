<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet
    xmlns="http://wadl.dev.java.net/2009/02"
    xmlns:wadl="http://wadl.dev.java.net/2009/02"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:c="http://www.w3.org/ns/xproc-step"
    xmlns:sch="http://docs.rackspace.com/core/usage/schema"
    xmlns:rax="http://docs.rackspace.com/api"
    xmlns:event="http://docs.rackspace.com/core/event"
    xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:novaHost="http://docs.rackspace.com/event/nova/host"
    xmlns:identityUser="http://docs.rackspace.com/event/identity/user"
    xmlns:xslout="http://www.rackspace.com/repose/wadl/checker/Transform"
    exclude-result-prefixes="sch c"
    version="2.0">

    <xsl:namespace-alias stylesheet-prefix="xslout" result-prefix="xsl"/>
    <xsl:output method="xml" encoding="UTF-8" indent="yes"/>
    <xsl:variable name="NS_PREFIX" select="'w_ns'"/>
    <!-- Event types, excepts for USAGE, which is a special case -->
    <xsl:variable name="EVENT_TYPES" as="xs:string*"
        select="('CREATE','USAGE_SNAPSHOT','UPDATE', 'DELETE', 'SUSPEND', 'UNSUSPEND', 'EXTENDED','UP','DOWN','INFO')"/>
    <xsl:template match="c:directory">
        <xsl:variable name="productSchemas" as="node()" select="sch:addSchemaPos(sch:getSchemas(.))"/>
        <xsl:variable name="wadlDoc" as="node()" select="sch:getWadlDoc(.)"/>
        <xsl:comment>
            <xsl:text>&#x0a;    THIS WADL IS AUTOGENERATED DO NOT EDIT</xsl:text>
            <xsl:text>&#x0a;    GENERATED ON: </xsl:text><xsl:value-of select="current-dateTime()"/>
            <xsl:text>&#x0a;    PRODUCT SCHEMAS:</xsl:text>
            <xsl:for-each select="c:file">
	      <xsl:sort select="@name"/>
                <xsl:text>&#x0a;           </xsl:text><xsl:value-of select="@name"/>
            </xsl:for-each>
            <xsl:text>&#x0a;</xsl:text>
        </xsl:comment>
        <xsl:text>&#x0a;</xsl:text>
        <application>
            <xsl:for-each-group select="$productSchemas/sch:productSchema" group-by="@namespace">
                <xsl:namespace name="{sch:ns(current-group()[1]/@pos)}" select="current-group()[1]/@namespace"/>
            </xsl:for-each-group>
            <xsl:for-each-group select="$productSchemas//sch:productSchema" group-by="@serviceCode">
                <xsl:variable name="id" select="current-group()[1]/@serviceCode"/>
                <resource_type id="{$id}">
                    <method id="add{$id}Entry" name="POST"><xsl:text>
		    </xsl:text>
		      	<xsl:comment>GENERATED FILE! Do Not Hand Edit!</xsl:comment>
		        <xsl:apply-templates select="$wadlDoc//wadl:doc[@rax:id = current-grouping-key()]" mode="copydoc"/>
                        <request>
                            <representation mediaType="application/atom+xml" element="atom:entry">
                                <xsl:call-template name="sch:param">
                                    <xsl:with-param name="type" select="'USAGE'"/>
                                    <xsl:with-param name="schemas" select="current-group()[not(@type) or ('USAGE' = tokenize(@type,' '))]"/>
                                </xsl:call-template>
                                <xsl:for-each select="$EVENT_TYPES">
                                    <xsl:variable name="type" select="."/>
                                    <xsl:call-template name="sch:param">
                                        <xsl:with-param name="type" select="."/>
                                        <xsl:with-param name="schemas" select="current-group()[$type = tokenize(@type,' ')]"/>
                                    </xsl:call-template>
                                </xsl:for-each>
                                <xsl:call-template name="sch:cross-check-params">
                                    <xsl:with-param name="schemas" select="current-group()"/>
                                </xsl:call-template>
                                <!--
                                    Hack, add nova updown check.
                                -->
                                <xsl:if test="$id = 'CloudServersOpenStack'">
                                    <param name="checkUp"
                                           style="plain"
                                           required="true"
                                           path="if (/atom:entry/atom:content/event:event/@type = 'UP') then not(/atom:entry/atom:content/event:event/novaHost:product/@checkStatus = 'CRITICAL') else true()"
                                           rax:message="If message is UP type then checkStatus cannot be CRITICAL."/>
                                    <param name="checkDown"
                                           style="plain"
                                           required="true"
                                           path="if (/atom:entry/atom:content/event:event/@type = 'DOWN') then not(/atom:entry/atom:content/event:event/novaHost:product/@checkStatus = 'OK') else true()"
                                           rax:message="If message is DOWN type then checkStatus cannot be OK."/>
                                </xsl:if>
                                <rax:preprocess href="atom_hopper_pre.xsl"/>
                                <xsl:call-template name="sch:searchable">
                                    <xsl:with-param name="schemas" select="current-group()"/>
                                    <xsl:with-param name="nscount" select="count(sch:getNSVersions($productSchemas//sch:productSchema))"/>
                                </xsl:call-template>
                                <!--
                                    Workaround, add a param for CloudIdentity
                                -->
                                <xsl:if test="$id = 'CloudIdentity'">
                                    <param name="checkUpdate"
                                           style="plain"
                                           required="true"
                                           path="if (/atom:entry/atom:content/event:event/@type = 'UPDATE' and /atom:entry/atom:content/event:event/identityUser:product/@version = '2') then /atom:entry/atom:content/event:event/identityUser:product/@updatedAttributes else true()"
                                           rax:message="For version 2 and type is UPDATE, the updatedAttributes attribute is required."/>
                                    <param name="checkNonUpdate"
                                           style="plain"
                                           required="true"
                                           path="if (/atom:entry/atom:content/event:event/@type != 'UPDATE' and /atom:entry/atom:content/event:event/identityUser:product/@version = '2') then not(/atom:entry/atom:content/event:event/identityUser:product/@updatedAttributes) else true()"
                                           rax:message="For version 2 and type is other than UPDATE, the updatedAttributes attribute should not be used."/>
                                </xsl:if>
                            </representation>
                        </request>
                        <!-- Okay -->
                        <response status="201">
                            <representation mediaType="application/atom+xml"/>
                        </response>
                        <!-- On Error -->
                        <response status="400 401 409 500 503">
                            <representation mediaType="application/xml"/>
                        </response>
                    </method>
                </resource_type>
            </xsl:for-each-group>
        </application>
    </xsl:template>
    <xsl:template name="sch:cross-check-params">
        <xsl:param name="schemas" as="node()*"/>
        <xsl:variable name="usedTypes" select="if ($schemas[not(@type)]) then
                                               distinct-values((sch:getTypes($schemas),'USAGE'))
                                               else sch:getTypes($schemas)"
                      as="xs:string*"/>
        <xsl:variable name="allTypes"  select="('USAGE', $EVENT_TYPES)" as="xs:string*"/>
        <xsl:variable name="notUsed" select="for $t in $allTypes return if ($t = $usedTypes) then () else sch:quoted($t)" as="xs:string*"/>
        <param name="cross_check" style="plain" required="true" rax:message="Events of this type not allowed in the feed.">
            <xsl:attribute name="path">
                <xsl:text>not(/atom:entry/atom:content/event:event/@type = (</xsl:text>
                <xsl:value-of select="$notUsed" separator=","/>
                <xsl:text>))</xsl:text>
            </xsl:attribute>
        </param>
    </xsl:template>
    <xsl:template name="sch:param">
        <xsl:param name="schemas" as="node()*"/>
        <xsl:param name="type" as="xs:string"/>
        <xsl:variable name="isUsageEvent">/atom:entry/atom:content/event:event[@type='<xsl:value-of select="$type"/>']</xsl:variable>
        <xsl:if test="$schemas">
            <xsl:variable name="nsVersions" select="sch:getNSVersions($schemas)"/>
            <xsl:variable name="events" as="xs:string*">
                <xsl:for-each select="$nsVersions">
                    <xsl:variable name="vers">
                        <xsl:variable name="v" select="tokenize(@versions,',')"/>
                        <xsl:choose>
                            <xsl:when test="count($v) = 1">
                                <xsl:value-of select="$v[1]"/>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:value-of select="concat('(',@versions,')')"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:variable>
                    <xsl:value-of select="concat($isUsageEvent,'/',@pfix,':product[@version = ',$vers,']')"/>
                </xsl:for-each>
            </xsl:variable>
            <param name="{lower-case($type)}" style="plain" required="true">
                <xsl:attribute name="path">
                    <xsl:text>if (</xsl:text><xsl:value-of select="$isUsageEvent"/>
                    <xsl:text>) then (</xsl:text>
                    <xsl:value-of select='$events' separator=","/>
                    <xsl:text>) else true()</xsl:text>
                </xsl:attribute>
                <xsl:attribute name="rax:message">
                    <xsl:text>Only </xsl:text><xsl:value-of select="lower-case($type)"/>
                    <xsl:text> messages with product attributes in the following namespaces are allowed on this feed: </xsl:text>
                    <xsl:value-of select="for $n in $nsVersions return concat($n/@namespace,' version(s) (',$n/@versions,')')" separator=", "/>
                </xsl:attribute>
            </param>
        </xsl:if>
    </xsl:template>
    <xsl:function name="sch:getNSVersions" as="node()*">
        <xsl:param name="schemas" as="node()*"/>
        <xsl:for-each-group select="$schemas" group-by="@namespace">
            <xsl:variable name="ns" as="xs:string" select="sch:ns(current-group()[1]/@pos)"/>
            <xsl:variable name="versions" as="xs:string*" select="current-group()/@version"/>
            <sch:ns pfix="{$ns}" namespace="{current-group()[1]/@namespace}">
                <xsl:attribute name="versions">
                    <xsl:value-of select="for $v in $versions return sch:quoted($v)" separator=","/>
                </xsl:attribute>
            </sch:ns>
        </xsl:for-each-group>
    </xsl:function>
    <xsl:template name="sch:searchable">
        <xsl:param name="schemas" as="node()*"/>
        <xsl:param name="nscount" as="xs:integer"/>
        <xsl:variable name="excludePrefixes" as="xs:string*"
                      select="('event', 'rax', 'util', 'xs',
                               for $i in 1 to $nscount return concat($NS_PREFIX,xs:string($i)))"/>
        <!--
            If we have at least one searchable attribute, then
            we need to add a preproc to handle it.
        -->
        <xsl:if test="$schemas//sch:attribute/@searchable">
            <rax:preprocess>
                <xslout:stylesheet
                    xmlns:event="http://docs.rackspace.com/core/event"
                    xmlns:atom="http://www.w3.org/2005/Atom"
                    version="1.0">
                    <xsl:attribute name="exclude-result-prefixes">
                        <xsl:value-of select="$excludePrefixes" separator=" "/>
                    </xsl:attribute>
                        <xslout:import href="util.xsl"/>
                        <xslout:output method="xml" encoding="UTF-8"/>
                        <xslout:template match="text()" mode="category"/>
                        <xslout:template match="node() | @*" mode="category">
                            <xslout:apply-templates select="@* | node()" mode="category"/>
                        </xslout:template>
                        <xsl:apply-templates select="$schemas" mode="addCategory"/>
                </xslout:stylesheet>
            </rax:preprocess>
        </xsl:if>
    </xsl:template>
    <xsl:template match="sch:productSchema[sch:attribute/@searchable | sch:attributeGroup/sch:attribute/@searchable]"
                  mode="addCategory">
        <xsl:variable name="namespace" as="xs:anyURI" select="@namespace"/>
        <xsl:variable name="version" as="xs:string" select="@version"/>
        <xslout:template match="atom:entry[atom:content/event:event/pf:product/@version='{$version}']">
            <xsl:namespace name="pf" select="$namespace"/>
            <atom:entry>
                <xslout:apply-templates select="@*"/>
                <atom:id><xslout:value-of select="atom:id"/></atom:id>
                <xslout:apply-templates mode="category" select="@* | node()"/>
                <xslout:apply-templates select="node()"/>
            </atom:entry>
        </xslout:template>
        <xslout:template match="atom:entry[atom:content/event:event/pf:product/@version='{$version}']/atom:id">
            <xsl:namespace name="pf" select="$namespace"/>
        </xslout:template>
        <xsl:if test="sch:attribute/@searchable">
            <xslout:template match="pf:product[@version='{$version}']" mode="category">
                <xsl:namespace name="pf" select="$namespace"/>
                <xsl:apply-templates mode="addCategory" select="sch:attribute"/>
                <xslout:apply-templates mode="category" select="@* | node()"/>
            </xslout:template>
        </xsl:if>
        <xsl:for-each select="sch:attributeGroup[sch:attribute/@searchable]">
            <xslout:template match="pf:{@name}[../@version='{$version}']" mode="category">
                <xsl:namespace name="pf" select="$namespace"/>
                <xsl:apply-templates mode="addCategory" select="sch:attribute"/>
                <xslout:apply-templates mode="category" select="@* | node()"/>
            </xslout:template>
        </xsl:for-each>
    </xsl:template>
    <xsl:template match="sch:attribute[@searchable]" mode="addCategory">
        <xsl:variable name="inAttribute" as="xs:boolean"
                      select="name(..) = 'attributeGroup'"/>
        <xslout:call-template name="addCategory">
            <xslout:with-param name="term" select="@{@name}"/>
            <xslout:with-param name="prefix"
                               select="'{if ($inAttribute) then concat(../@name,'.',@name) else @name}:'"/>
            <xsl:if test="@default">
                <xslout:with-param name="default" select="'{@default}'"/>
            </xsl:if>
        </xslout:call-template>
    </xsl:template>
    <xsl:function name="sch:ns" as="xs:string">
        <xsl:param name="pos" as="xs:integer"/>
        <xsl:value-of select="concat($NS_PREFIX,$pos)"/>
    </xsl:function>
    <xsl:function name="sch:quoted" as="xs:string">
        <xsl:param name="in" as="xs:string"/>
        <xsl:variable name="q" select="''''"/>
        <xsl:value-of select="concat($q,$in,$q)"/>
    </xsl:function>
    <xsl:function name="sch:getTypes" as="xs:string*">
        <xsl:param name="schemas" as="node()*"/>
        <xsl:copy-of select="distinct-values(for $s in $schemas return tokenize($s/@type,' '))"/>
    </xsl:function>
    <xsl:function name="sch:getSchemas" as="node()">
        <xsl:param name="dir" as="node()"/>
        <sch:productSchemas>
            <xsl:for-each select="$dir/c:file">
                <xsl:sort select="@name"/>
                <xsl:apply-templates select="document(concat(base-uri(),'/',@name))//sch:productSchema" mode="copy"/>
            </xsl:for-each>
        </sch:productSchemas>
    </xsl:function>
    <xsl:function name="sch:getWadlDoc" as="node()">
        <xsl:param name="dir" as="node()"/>
        <sch:productSchemas>
            <xsl:for-each select="$dir/c:file">
                <xsl:sort select="@name"/>
                <xsl:apply-templates select="document(concat(base-uri(),'/',@name))//wadl:doc" mode="copy"/>
            </xsl:for-each>
        </sch:productSchemas>
    </xsl:function>
    <xsl:function name="sch:addSchemaPos" as="node()">
        <xsl:param name="schemas" as="node()"/>
        <sch:productSchemas>
            <xsl:for-each-group select="$schemas//sch:productSchema" group-by="@namespace">
                <xsl:variable name="pos" select="position()"/>
                <xsl:for-each select="current-group()">
                    <sch:productSchema pos="{$pos}">
                        <xsl:apply-templates select="@* | node()" mode="copy"/>
                    </sch:productSchema>
                </xsl:for-each>
            </xsl:for-each-group>
        </sch:productSchemas>
    </xsl:function>
    <xsl:template match="node() | @*" mode="copy" priority="2">
        <xsl:copy>
            <xsl:apply-templates select="@* | node()" mode="copy"/>
        </xsl:copy>
    </xsl:template>
    <xsl:template match="node() | @*" mode="copydoc" priority="2">
        <xsl:copy>
            <xsl:apply-templates select="@* | node()" mode="copydoc"/>
        </xsl:copy>
    </xsl:template>
    <xsl:template match="@rax:id" mode="copydoc" priority="100"/>
    <xsl:template match="text()" mode="#all"/>
</xsl:stylesheet>
